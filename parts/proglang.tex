A programozási nyelv algoritmusok leírására szolgáló formális jelölésrendszer, amelyet emberek és számítógépek is értelmezni tudnak.
A programozási nyelv szolgálhat ember és gép közötti kommunikáció eszközeként, lehetővé téve a programozónak, hogy a feladatot megoldó algoritmust a számítógép számára érthető módon megfogalmazza.
De a programozási nyelv kommunikációs eszköz lehet ember és ember között is, hiszen a megírt programot a programozón kívül mások is olvasni fogják majd, akár mert javítaniuk kell a programon, akár mert tovább akarják fejleszteni, akár mert tanulni akarnak belőle.


\subsection{Történeti áttekintés}
Az embernek és a gépnek a közös nyelvvel szemben támasztott igényei jelentősen eltérnek.
Kezdetben, a számítógépek megjelenésekor egyértelműen a gépek igényei voltak előtérben: a programozónak ténylegesen a gép nyelvén kellett beszélnie, \textbf{gépi kód}ban kellett közölnie a gondolatait, vagyis ténylegesen bináris számok sorozataként kellett megírnia a programját, ahol minden szám egy-egy gépi utasítást, illetve az utasítás operandusaiként szolgáló memóriacímeket jelölte.
Ez nagyon távol áll az emberi gondolkodástól, a természetes nyelven kifejezett algoritmustól: a program lefordítása a gép nyelvére a programozó igen nehéz és munkaigényes feladata volt, a program olvasása pedig hasonlóan nehéz.

Az ember-orientált nyelvek kialakulásának első lépése a csak embereknek szánt programleíró jelölésrendszerek megjelenése volt: Konrad Zuse \textit{Plankalkül}je, Neumann János és Herman Goldstine programleíró folyamatábrái, Currie lambda-kalkulusa voltak az első olyan rendszerek, amelyek lehetővé tették algoritmusok formális leírását.
Érdemes megjegyezni, hogy bár a matematika nagyon fejlett eszköztárat épített ki statikus struktúrák leírására, az algoritmusokat egészen addig természetes nyelven adták meg\cite{KnuthTrabbPardo}.

A negyvenes évek végén jelentek meg az első \textbf{assembly-szintű nyelvek}, ahol bináris számok helyett a programozó már rövid nevekkel, mnemonikokkal hivatkozhatott egy gépi utasításra, és konkrét memóriacímek helyett már azonosítókkal hivatkozhatott változókra.
Az így leírt programot táblázatok segítségével könnyű átírni gépi kódra, és ez a fordítási folyamat könnyen automatizálható is: így jelentek meg az assemblerek, az első fordítóprogramok.
Ez volt at első lépés az ember-orientált nyelvek kifejlődése felé: a programozóknak nem kellett többé numerikus utasításkódokat észben tartaniuk vagy memóriacímeket számolniuk, sőt, a fordítóprogram már képes volt bizonyos hibákat felderíteni a kapott programban. És bár az assembly-szintű nyelvekben eleinte a gépi utasítások és az assembly mnemonikok között egy-egy kapcsolat volt, de hamarosan megjelentek az első ,,makrók'', azaz makróutasítások (vagyis szó szeint ,,óriásutasítások'') is,  amelyek több gépi utasításból álló sorozatokat helyettesítettek.
Megjelentek az első szubrutinkönyvtárak is, amelyek lehetővé tették a programozó számára a magasabb absztrakciós szinten való gondolkodást.

Az ilyen korai \textit{autocoding} technikák fejlődésével alakultak ki a \textbf{magasszintű nyelvek}, melyeket architektúrafüggetlenség, a magas absztrakciós szint biztosítása, az assemblyhez képest rövidebb, áttekinthetőbb szerkezetű programok írásának lehetősége jellemez, és az, hogy a nyelv közelebb áll az emberi nyelvhez.
%Az első sikeres magasszintű nyelv a FORTRAN volt, tervezési céljai közül a tömörség és a gyors elsajátíthatóság voltak a lefontosabbak.
Fejlődésükben katalizátorként hatott Noam Chomsky generatív nyelvelmélete, melynek alapján viszonylag komplex nyelvtani struktúrákat hatékonyan felismerő és gépi nyelvre fordító algoritmusokat lehetett kidolgozni.

A magasszintű nyelvek kifejlesztésének motivációja a programozói termelékenység növelése volt\cite{Backus78}, a programozók körében mégis sokáig érezhető volt egyfajta ellenérzés a magasszintű nyelvekkel szemben, mondván, hogy a magasszintű nyelvek emberorientáltsága a \textit{hatékonyság} és a \textit{kreativitás} rovására megy\cite[12.~fejezet]{MythManMonth}.
A számítógépek teljesítményének fejlődésével és az egyre szofisztikáltabb fordítóprogramok megjelenésével ezek a kritikák háttérbe szorultak ugyan, de ezzel párhuzamosan egyre magasabb szintű, egyre emberorientáltabb programozási nyelvek jelentek meg, melyekkel szemben a korábbi magasszintű nyelvek kedvelői fogalmaztak meg hasonló kritikákat.
A \textit{magasszintű nyelv} kifejezés így egyre magasabb szintű nyelvekre utal: az első magasszintű nyelveket egy mai programozó már jórészt alacsonyszintűnek tekinti.
A ma programozója számára ,,túl magas'' szintű programozási nyelvek például a programkódot automatikusan generáló szoftvertervezési eszközök; ezekkel szemben a mai programozók hasonlóan a hatékonyságot és a kreativitást féltik, mint a hatvanas évek programozói a magasszintű nyelvektől\cite{Veto}.


\subsection{Fogalmak}
A nyelv \textbf{szintaxis}a azon szabályok halmaza, amelyek megadják a nyelven írható összes formailag helyes programot. A szintaxis megadható formális környezetfüggetlen%
\footnote{
	Bizonyos programozási nyelvek szintaxisát környezetfüggőnek mondják, híres példa erre a C++, azonban a környezetfüggőség gyakran a lexikális sajátosságok eredménye.
	Definícióink mindenképp határozottabbak és egyértelműbbek lesznek, ha a szintaxist mindig környezetfüggetlennek tekintjük, és a környezetfüggő elemeket a statikus szemantika hatáskörébe soroljuk; ráadásul ez a megközelítés jól tükrözi a fordítóprogramok működését.
}
nyelvtannal, ekkor a nyelv szintaktikailag helyes programjainak halmaza a nyelvtan által generált mondatok halmaza, $\mathbb{M}_\mathcal{L}$. Egy ilyen mondat levezetési fáját szintaxisfának nevezzük.
Megkülönböztethetjük a \textit{felszíni} és \textit{absztrakt} szintaxist: míg a felszíni szintaxis szabályai tényleges szövegekkel, karakterláncokkal operálnak, és ezekről döntik el, hogy alkothatnak-e formailag helyes programot; addig az absztrakt szintaxis szabályai a program ,,mélystruktúrájával'' foglalkoznak, és nem törődnek azzal, hogy egy absztrakt nyelvi elemnek milyenek a felszíni megnyilvánulásai, lexikális tulajdonságai.
Az absztrakt szintaxishoz \textbf{lexikális szabályok}at rendelve felszíni szintaxist kapunk.
%A programozási nyelvek szintaxisát a gyakorlatban rendszerint a Backus-Naur formát használva adják meg, amely könnyen írható és olvasható emberek és gépek számára is.

A nyelv \textbf{szemantiká}ja a formálisan helyes mondatok jelentését megadó szabályok összessége.
Megkülönböztetjük a \textit{statikus szemantiká}t és a \textit{dinamikus szemantiká}t: a statikus szemantika a programok futtatás előtti viselkedésével, míg a dinamikus szemantika a program futásidejű viselkedésével foglalkozik.
A statikus szemantika szabályai a formailag helyes programok halmazát tovább szűkitik egy $\mathbb{P}_\mathcal{L} \subseteq \mathbb{M}_\mathcal{L}$ halmazra, amelyet az \textit{érvényes programok} halmazának nevezünk: a gyakorlatban ezek azok a programok, amelyeket a fordítóprogram hiba nélkül elfogad.
A dinamikus szemantika szabályai minden érvényes programhoz megadják a program pontos futásidejű viselkedését.

Az absztrakt szintaxis elemeit \textbf{programkonstruktor}oknak, a programkonstruktorokat és a hozzájuk kapcsolódó szemantikai szabályokat együttesen pedig \textbf{nyelvi elemek}nek nevezzük.
Ezek azok az alapvető építőelemek amelyeket használva a programozó felépítheti programját.

Bizonyos elemhalmazokról igazolható, hogy ha ezeket tartalmazza egy nyelv, akkor a nyelv \textbf{univerzális}, más néven \textbf{Turing-teljes}, vagyis a nyelvvel szimulálható egy Turing-gép, ami azt jelenti, hogy minden lehetséges algoritmus kifejezhető csak az adott elemeket használva.
Procedurális nyelvek esetében történelmi és kényelmi okokból a \textit{szekvencia}, az \textit{elágazás} és a \textit{ciklus} halmazának meglétét szokás a nyelv univerzalitását biztosítónak tekinteni: ha egy nyelvben ez a három nyelvi elem létezik, akkor az a nyelv biztosan univerzális\cite{Fothi}.

\bigskip

\noindent A fentiek alapján formális definíciót is adhatunk a programozási nyelv fogalmára:
\begin{defn}[Programozási nyelv\protect{\cite[3.1~definíció]{Felleisen90}}]
	Egy $\mathcal{L}$ programozási nyelv megadható az $\mathcal{L} = (
		\mathbb{M}_\mathcal{L},
		\mathbb{P}_\mathcal{L},
		eval_\mathcal{L}
	)$ rendezett hármassal, ahol
	\begin{itemize}
		\item $\mathbb{M}_\mathcal{L}$ a nyelv mondatainak, a nyelv $\mathbb{K}_\mathcal{L} = \{K_1 \ldots K_n\}$ programkonstruktoraiból szabadon generált absztrakt szintaxisfák halmaza.
		\item $\mathbb{P}_\mathcal{L} \subseteq \mathbb{M}_\mathcal{L}, \mathbb{P}_\mathcal{L} \not= \emptyset$, az $\mathcal{L}$-beli programok halmaza.
		\item $eval_{\mathcal{L}}$ a $\mathbb{P}_\mathcal{L}$ felett értelmezett predikátum, a nyelv dinamikus szemantikája, amely akkor igaz, ha a program elvégzi a feladatát%
		\footnote{
Felleisen $eval_\mathcal{L}$-t olyan predikátumként definiálja, ami akkor igaz, ha a program terminál\cite{Felleisen90}, ezzel  definíciója a lehető legáltalánosabb. Ezt túl megengedőnek érzem, ezért választottam ezt a homályos, ám intuitív meghatározást. Ennek pontosabb definiálására egy mód lehet az $eval_\mathcal{L}$ $\left<feladat, program\right>$ párok feletti értelmezése.
		}.
	\end{itemize}

	\normalfont Az így meghatározott absztrakt nyelv lexikális sajátosságait egy $R: \mathbb{K} \rightarrow \Sigma^*$, a nyelv programkonstruktoraihoz szimbólumsorozatokat rendelő függvény megadásával definiálhatjuk. Ha ez a leképezés nem injektív, a nyelv felszíni szintaxisa környezetfüggő lesz.
\end{defn}

\begin{defn}[Konzervatív kiterjesztés\protect{\cite[3.2~definíció]{Felleisen90}}]
	Egy $\mathcal{L}$ nyelv $\{K_1 \ldots K_n\}$ elemekkel való konzervatív kiterjesztése egy $\mathcal{L}'$ nyelvnek, ha
	$ \{K_1 \ldots K_n\} \cap \mathbb{K}_{\mathcal{L}'} = \emptyset$,
	$\mathbb{K}_\mathcal{L} = \mathbb{K}_{\mathcal{L}'} \cup \{K_1 \ldots K_n\}$,
	$\mathbb{M}_{\mathcal{L}'} \subset \mathbb{M}_\mathcal{L}$, $\mathbb{P}_{\mathcal{L}'} \subset \mathbb{P}_\mathcal{L}$, és $ \forall P \in \mathbb{P}_{\mathcal{L}'}: eval_{\mathcal{L}'}(P) = eval_\mathcal{L}(P)$. Ekkor $\mathcal{L}'$-t $\mathcal{L}$ leszűkítésének mondjuk.

	\normalfont Vagyis $\mathcal{L}$-t úgy kapjuk, hogy $\mathcal{L}'$-höz hozzáadunk pár új nyelvi elemet, de minden, a régi nyelven írt program a kiterjesztett nyelvben is program, és ezek futásidejű viselkedése sem változik.

	\normalfont A konzervatív kiterjesztésre a $\mathcal{L} = \mathcal{L}' + \{K_1 \ldots K_n\}$ jelölést, míg a leszűkítésre a $\mathcal{L}' = \mathcal{L} \setminus \{K_1 \ldots K_n\}$ jelölést használjuk.
\end{defn}


\begin{defn}[Nyelvhasználat]
Azt mondjuk, hogy egy $K$ programkonstruktor nem része egy programozó nyelvhasználatának, ha programjaiban soha nem jelenik meg $K$.
Ekkor a programozó által használt $\mathcal{L}'$ nyelv az ideális $\mathcal{L}$ nyelv leszűkítése, $\mathcal{L}' = \mathcal{L} \setminus \{K\}$.

\normalfont Egy programozó nyelvhasználatából egy nyelvi elem hiányozhat technikai megfontolásokból (mert ,,nem hatékony''), mert a használata nem illendő (jó példa erre a \cls{goto} utasítás, ami ugyan a legtöbb nyelvben máig létezik, még olyan modern nyelvekben is, mint a Ruby, de használata a magasszintű programozásban teljesen eltűnt), vagy akár mert nem tud az adott nyelvi elem létezéséről.
Naivnak tűnhet a feltételezés, hogy egy aktív és képzett programozó nem tud egy nyelvi elemről, de gondoljunk bele, hogy egy nyelv standard könyvtárának függvényei is nyelvi elemek; másrészt a modern programozási nyelvek gyakran nagyon komplexek, emberek számára nehezen megismerhetőek a maguk teljességében.

Például e sorok szerzője csak a múlt év őszén tudtam meg, hogy a Javában létezik konstruktordelegáció: az általam használt Java azóta sokkal jobb minőségű, mint azelőtt.
\end{defn}


\subsection{Programozási nyelvek minőségi mutatói}
Az univerzális programozási nyelvek számításelméleti szempontból teljesen azonosak: tetszőleges rendelkezésre álló idő és memória mellett bármely számítás elvégezhető velük.
Intuitívan érezzük viszont, hogy a nyelvek között minőségi különbségek vannak, ez a különbség viszont nehezen megfogható: magas és alacsony szintű nyelvek között könnyű minőségi különbséget találni, de két magasszintű nyelv minőségét nehéz összehasonlítani.

\subsubsection{Kifejezőerő}
A programozók informálisan gyakran mondják, hogy ez vagy az a nyelv \textit{nagyobb kifejezőerővel bír}: hogy egy algortimus könnyebben, elegánsabban implementálható egy nyelvben, mint a másikban, hogy egy nyelvben könnyebben kifejezik magukat, mint egy másikban.
Az az intuitív meglátásunk is hamar kialakul, hogy némely nyelvi elem fontosabb a kifejezőerő szempontjából, mint a többi: némelyik lényeges, némelyik meg csak \textit{szintaktikus cukormáz}, amely könnyen kifejezhető más nyelvi elemekkel, így a nyelv kifejezőerejéhez nem ad hozzá, csak édesebbé teszi a nyelvet az emberek számára.\cite{Landin64}

A kifejezőerő szubjektív fogalom, de voltak kísérletek a definiálására: a hacker-kultúrában\cite{Graham02} és a szoftvertechnológiában\cite{MythManMonth}\cite{CodeComplete} is meghatározó nézet szerint egy nyelv kifejezőereje a \textit{tömörségével} (\textit{succintness}) arányos -- egy nyelv annál kifejezőbb, minél kevesebb szóval tudok elmondani valamit.
Ez jól illik a kifejezőerőről alkotott intuitív képünkhöz: a tökéletes programozási nyelv az volna, amelyben bármely feladat egyetlen utasítással megoldható.

Ha a kifejezőerő arányos a nyelv tömörségével, a kifejezőerő mérhető egy program sorokban, karakterekben, utasításokban mért hosszával, esetleg a tömörített forráskód méretével%
\footnote{%
Az elterjedt tömörítő eljárások optimálisak, közelítik a Shannon forráskódolási tételéből ismert tömörítési határt, így a tömörített file mérete mond valamit a forrásszöveg entrópiájáról, információtartalmáról.
Ez a megközelítés vonzóan tudományosnak tűnhet, amíg fel nem ismerjük, hogy a forrásszöveg entrópiája alapvetően a programot leíró szöveg karakterereinek eloszlásától függ, ami tisztán lexikális kérdés, és nincs nagyobb összefüggésben a nyelv kifejezőerőerejével, mint a karakterek száma.
Ilyen megközelítésért lásd például a The Computer Language Benchmarks Game oldalt: \url{http://benchmarksgame.alioth.debian.org}.
}%
: ezek statisztikák készítésére könnyen alkalmazható metrikák, de az eredményeket jelentősen torzítják a nyelv lexikális sajátosságai, névadási és tördelés konvenciói, melyekről érezzük, hogy bár fontosak, nem kellene igazán befolyásolniuk a kifejezőerőt.
Ezt a problémát kiküszöbölhetjük, ha a tömörséget egy program absztrakt szintaxisfájának elemszámával mérjük, de megfelelő elemzőt írni minden vizsgálandó nyelvhez nehéz feladat.
Akármilyen metrikát választunk is, a program méretének mérése, mint a statisztikai nyelvtechnológiai eszközök általában, csak akkor használható, ha nagy korpusszal dolgozunk, a nyelv ismerete önmagában tehát nem elégséges a nyelv kifejezőerejének vizsgálatához.
Ráadásul a kifejezőerőt tisztán a tömörséggel magyarázó elmélet -- formális definíció híján -- nem ad lehetőséget, hogy bármit rigorózusan bizonyítsunk egy nyelvről.
Nem igazán teszi lehetővé azt sem, hogy nyelvi elemekről érveljünk: szintaktikus cukormáz-e, vagy létfontosságú?

Mathias Felleisen a formális rendszerek elméletének eszköztárát felhasználva épített rendszert a kifejezőerő leírására és elemzésére\cite{Felleisen90}.
Informálisan úgy foglalhatjuk össze, hogy $\mathcal{L}$ kifejezőbb $\mathcal{L}' = \mathcal{L} \setminus \{K_1 \ldots K_n\}$-nél, ha egy $\mathcal{L}$-beli, valamely $K_i$ konstruktort tartalmazó program lefordításához $\mathcal{L}'$-re a program globális átszervezése szükséges.
Azokat a programkonstruktorokat pedig, amelyeknek fordításához csak lokális transzformációkra van szükség, kifejezhetőnek vagy \textit{eliminálhatónak} mondjuk.
A $\varphi: \mathcal{L} \rightarrow \mathcal{L}'$ fordítási függvény tulajdonságainak megkötésével definiálhatjuk a kifejezőerő különböző szintjeit. %ez így tré, példa, függvényelim

Felleisen rendszerét használva a nyelvtervezés folyamán formálisan is bizonyítható, hogy egy nyelvi elem hozzáadása ténylegesen változtat-e a nyelv kifejezőerején.


\subsubsection{Belső kiterjeszthetőség és makrókifejezhetőség}
Egy kiterjeszthető nyelvben a programozó új nyelvi elemeket hozhat létre.
A legtöbb nyelv kiterjeszthető valamilyen szinten, például lehetőséget biztosít alprogramok, új adattípusok létrehozására.
Néhány nyelv arra is eszközt biztosít, hogy a programozó tetszőleges új nyelvi elemeket hozzon létre: a Lisp makró konstrukciói segítségével például a nyelv tetszőleges programkonstruktorokkal bővíthető.
Ezeket az eszközöket a \textit{szintaktikai absztrakció eszközei}nek nevezzük, és segítségükkel a kifejezőerő egy új szintjét definiálhatjuk.

Azt mondjuk, hogy egy $K$ nyelvi elem \textit{makrókifejezhető} $\mathcal{L}'$-ben, ha létezik egy megfelelő $A$ szintaktikai absztrakció, amelyre
$\varphi (K(e_1 \ldots e_n) ) = A(\varphi(e_1) \ldots \varphi(e_n))$; vagyis a nyelvi elem eliminálása nem csak a program globális struktúráját őrzi meg, hanem az eliminált L-mondat alkotóelemeinek struktúráját is\cite[3.11~definíció]{Felleisen90}. Ez a definíció nagyon közel áll a szintaktikus cukormázról alkotott intuitív képünkhöz.

Látható, hogy a nyelv kifejezőerejét megsokszorozza egy szintaktikai absztrakciós eszköz; és minél megengedőbbek az absztrakciós eszközök, annál nagyobb a nyelv kifejezőereje. Így például egy alprogram-absztrakciót biztosító nyelv, amelynek alprogramjai elfogadnak paraméterként szekvenciát, nagyobb kifejezőerejű, mint amelyiknek alprogramjai nem tudnak szekvenciát kezelni paraméterként. %ez elég esetlen


\subsubsection{Hasznosság és használhatóság}
\label{subsec:utility_and_usefulness}
A programozási nyelv az ember és gép közötti kommunikáció eszköze, ezért értelmezhetőek rá a felhasználói felületek minőségi mutatói\cite{McIver01}.
Egy programozási nyelv \textbf{hasznos} (\textit{useful}) ha lehetővé teszi, hogy a programozó gyorsan és hatékonyan írja meg a feladatát megvalósító programot. A hasznosság fő metrikái:
\begin{description}
	\item[Kifejezőerő] Két nyelv közül a nagyobb kifejezőerejű a hasznosabb. Ez ugyan reláció, és nem metrika, de a nyelv szintaktikai absztrakciós eszközeinek száma és minősége jó becslés egy abszolút kifejezőerőre.
	\item[Robosztusság] A programozó hibája nem járhat katasztrofális következményekkel. A nyelv robusztus, ha nyelvi elemei lehetővé teszik a hatékony hibadetektálást.
	\item[Emberorientáltság] A nyelv emberorientált, ha amikor csak lehet, a programozó igényeit a gép igényei elé helyezi.
	\item[Feladatorientáltság] A nyelvnek csak azokat a nyelvi elemeket kell biztosítania, amelyeket a programozók feladataik során használnak; és nem szabad olyan nyelvi elemeket biztosítania, amelyeket nem használnak. Ugyanis minél több nyelvi elemet biztosít egy nyelv, annál komplexebb, nehezebben használható lesz, arányosan kisebb lesz a programozók nyelvhasználata.
\end{description}

Ezek a metrikák gyakran nehezen mérhetőek, de objektívek. Ezzel szemben a \textbf{használhatóság} (\textit{usability}) metrikái eredendően szubjektívek, egy nyelv -- vagy bármely rendszer -- használhatósága a felhasználó demográfiai hátterétől és tapasztalatától függ\cite{Veto}.
A használhatóság analízisére Green adott 1989-ben objektív, racionális rendszert, amelyet a \textit{jelölésrendszerek kognitív dimenziói}nak (\textit{cognitive dimensions of notation}, CD) nevezett el\cite{Green89}.
A CD rendszere 14, páronként független dimenziót ad egy jelölésrendszer használhatóságának meghatározására\cite{GreenBlackwell98}. Ezekből a programozási nyelvek szempontjából legfontosabbak a következők:

\begin{description}
	\item[Absztrakció] Milyen szintaktikai absztrakciós eszközöket biztosít a nyelv? Hány ilyen eszköz használatát kell elsajátítani a nyelv minimális használatához?
	\item[Hibák vonzása] Mennyire növeli a nyelv a programozói hibák előfordulásának esélyét?
	\item[Konzisztensség] Hasonló dolgok hasonló módon fejezhetőek ki a nyelvben? Hasonló szemantikájú nyelvi elemek hasonló szintaktikával és lexikális tulajdonságokkal rendelkeznek?
	\item[Leképezés közelisége] Mennyire könnyen fejezhető ki a nyelven a programozó algoritmusa, hány nyelvi elem felel meg a programozó elvi megoldásának egy lépésének, milyen könnyen fejezhető ki a feladat állapotterének műveletei a nyelvben?
	\item[Szellemi erőfeszítés] Mekkora erőfeszítést kíván a nyelv használata?
	\item[Szerepkifejezés] Mennyire nyilvánvaló, hogy egy dolog mire jó? Milyen mértékben lehet következtetni egy nyelvi elem szemantikájára a szintaxisa és lexikális tulajdonságai alapján?
	\item[Terjengősség] Milyen röviden lehet kifejezni egy algoritmust a nyelven? Milyen hosszúak a nyelv lexémái?
	\item[Viszkozitás] Mekkora a kis változtatások ára? Mennyire változtatható egy program lokális struktúrája a globális struktúra változtatása nélkül?
\end{description}

Egyik dimenzió sem egyértelműen ,,jó'' vagy ,,rossz'', a dimenziók megítélése a nyelv feladatától függ.


\subsection{Oktatási célú programozási nyelvek}
\label{subsubsec:edulang}
A programozás oktatása más követelményeket támaszt egy nyelvvel szemben, mint az ipari felhasználás\cite{McIver01}.
A kognitív dimenziók optimális értékei a kifejezetten a programozás alapjainak oktatására szánt nyelvre a következőképpen alakulnak:

\paragraph{Absztrakció -- alacsony} Az oktatási nyelv \textit{absztrakciós korlát}jának, vagyis a nyelv használatához minimálisan megtanulandó absztrakciós eszközök számának nagyon alacsonynak kell lennie, és egyszerű programok írásához nem is szükséges túl sok absztrakciós eszköz.
A Java nyelvben például már a legegyszerűbb program írásához találkozni kell az objektumosztály fogalmával.

\paragraph{Hibák vonzása -- nagyon alacsony} A hiba frusztrálja és elbizonytalanítja a tanulót, a nyelvtervezés során minden áron törekedni kell a programozói hibalehetőségek minimalizálására.
Az C++ utasításlezáró pontosvesszőjének elhagyása például gyakori hiba, amit a kezdők nehezen is azonosítanak, hiszen a \cls{gcc} fordítóprogram hibaüzenete szót sem ejt pontosvesszőről.

\paragraph{Konzisztensség -- közepes} A konzisztensség segíthet a tanulónak, hiszen ha elsajította egy nyelvi elem használatát, akkor automatikusan használni fogja tudni a hasonló nyelvi elemeket.
Ugyanakkor nem biztos, hogy a kezdő képes felismerni egy szemantikai hasonlóságot két nyelvi elem között, illetve nem tudja kihasználni az elvi hasonlóságot.
Jó példa a túlzásba vitt konzisztensségre a Turing és az Ada nyelvek tömbelem-lekérdező operátora, ami ugyanúgy sima zárójelként jelenik meg, mint a függvényhívás, mondván, hogy mindkettő értéklekérés; a diák ugyanakkor egy \cls{A(1)} konstrukciót látva nem tudja eldönteni, hogy \cls{A} változó-e vagy függvény.

\paragraph{Leképezés közelisége -- nagyon magas} A nyelvnek illeszkednie kell a tanulók feladatához és megoldásához, tükröznie kell a tanulók létező ismereteihez, világképéhez; de mutatnia kell az elsajátítandó világképet is.
A Pascal oktatónyelv például jó leképezése egy ideális virtuális gépnek, de a kezdők világképétől távol áll, ami különösen a tömbök és a karakterláncok nehézkes kezelésénél szembetűnő.

\paragraph{Szellemi erőfeszítés -- alacsony} A programozás során elkerülhetetlen a szellemi erőfeszítés, de nem szabad, hogy a nyelv használata szükségtelenül nehezítse a feladat megoldását. A Scheme oktatónyelvben például a lambda-kalkulus igényeihez idomulás nehéz feladat a kezdő programozónak.

\paragraph{Szerepkifejezés -- magas} Jól megválasztott felszíni szintaxis mellett a tanuló sokkal könnyebben olvashat és érthet meg programokat.
Egy jó szerepkifejezésű nyelvi elem nem igényel különösebb magyarázatot, használata azonnal értetődő.
Például a C++ \cls{cout << "Hello world";} utasítása sokkal kevésbé szerepkifejező, mint a Pascal-szerű \cls{print "hello world"}: a \cls{cout} szóval ellentétben a \cls{print} felismerhető a laikus számára is, a \cls{<<} operátor megértése pedig abszolút fejlettebb tudást kíván.

\paragraph{Terjengősség -- közepes} A nyelvnek strukturálisan elég tömörnek kell lennie ahhoz, hogy egyszerű programokat nagyon röviden, redundancia nélkül ki lehessen fejezni, de a túlzott tömörség az olvashatóság rovására megy.
Bőbeszédű nyelv például az AppleScript, amelynek a természetes nyelvhez való hasonlósága gyakran a programstruktúra átláthatatlanságához vezet.

\paragraph{Viszkozitás -- alacsony} A programozás tanulása gyakran jár kísérletező próbálgatással\cite{McIver01}; ha ez a próbálgatás, a programok változtatgatása nehéz és kényelmetlen feladat, a tanuló lelkesedése csökkenni fog, frusztrációhoz vezethet.
Magas viszkozitású nyelv például az Ada: deklarációs blokkjai, erős típusossága, import-szabályai, nehézkes fordítási mechanizmusa mind nehezítik a gyors próbálgatást.\\[\baselineskip]
A kifejezetten a programozás alapjainak egyetemi szintű oktatására szánt nyelv esetében a hasznosság metrikái közé soroljuk a \textbf{módszertani helyesség} támogatását: a nyelvnek alakítania kell a diák gondolkodásmódját, jó programozói szokások, programozástechnikai és számítástudományi alapvetések elsajátítására kell késztetnie.
Ez gyakran ellentétbe kerül a használhatóság metrikáival: módszertanilag helyes megkülönböztetést tenni például függvények és eljárások között, bár a tanulók ilyen megkülönböztetést nem tesznek\cite{McIver01}.
